<?php

/*
The tutorial I started from
https://medium.com/@cn007b/super-simple-php-websocket-example-ea2cd5893575

Also, I had to run these commands to open port 50:
https://docs.e2enetworks.com/security/firewall/iptables.html
iptables -I INPUT -p tcp --dport 50 -j ACCEPT
iptables -I INPUT -p udp --dport 50 -j ACCEPT
ip6tables -I INPUT -p tcp --dport 50 -j ACCEPT
ip6tables -I INPUT -p udp --dport 50 -j ACCEPT
(replace ACCEPT with DROP to close the ports)

The code below was from a research project at work... nothing ever came of
that project, so I think I'm good to use it here... but so far, no dice.

I also tried a couple examples generated by an AI:
https://www.perplexity.ai/search/24b80c9d-a2f7-435b-8a5a-68577a854772?s=u

But no matter what I do, I get an error "broken pipe" on socket_write.
I'm sure there's sume sneaky withcy config-rig that has to be done, some
annoying growl-inducing piece'o'crap that gets its bits in a twist someplace
only my Lord and maybe The Inventor Of PHP Him/Herself might understand. :-P

So.... fight for another night.


*/
include('./web-sockets.php');

$socket = ws_create('localhost', 50);
$not_used = NULL;
$clientSocketArray = array($socket);
while (true) {
	$newSocketArray = $clientSocketArray;
	socket_select($newSocketArray, $not_used, $not_used, 0, 10);

	// I think what this does is make sure the socket appears in the
	// only array once by un-setting it if it finds it already in the array
	if (in_array($socket, $newSocketArray)) {
		$client = ws_create_client($socket);
		$clientSocketArray[] = $client;
		$newSocketIndex = array_search($socket, $newSocketArray);
		unset($newSocketArray[$newSocketIndex]);
	}

	foreach ($newSocketArray as $sock) {
		// Get a message from each client
		$data = ws_read($sock);
		if (!$data) continue;	// If I need to debug, call socket_strerror(socket_last_error())
			
		// Send it to all clients
		foreach($clientSocketArray as $sock2)
			ws_write($sock2, $data);
	}
}
socket_close($socket);

